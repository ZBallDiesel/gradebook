---
title: "Example with GS Demo Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{GS Demo Demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This article walks through how this package is used to process student assignment scores according to the given syllabus. This workflow requires two inputs: student data (ideally from Gradescope) and a policy file.

```{r setup}
library(gradebook)
```

### Load in student data

Student data is formatted according to Gradescope .csv format, where each unit of observation is a student and each individual assignment includes the student's score, the maximum allowed points, the student's submission timestamp and how late the student submitted (in HH:MM:SS format). Below is the Gradescope demo data found within the package.

```{r}
gs_demo
```

### lower_colnames()
This function changes all column names to lowercase for consistent data processing.

```{r}
gs_demo |>
    lower_colnames()
```

### check_data_names()
This function checks that the general formatting for the column names of the Gradescope data. This checks that all assignments are uniformly formatted by their raw points, the maximum points, the submission time and lateness. This also checks that the first few columns of the Gradescope data include ID columns used to identify students, such as student ID. If there is incorrect formatting, the function will return a relevant error. If not, this function returns the same dataframe in order for these functions to be pipeable.

```{r}
gs_demo |>
    lower_colnames() |>
    check_data_colnames_format()
```

### drop_ungraded_assignments()
This function drops any ungraded assignments. This is just to cut down on the size of the Gradescope data. It removes any assignments where the raw scores are all NAs for every student.

```{r}
gs_demo |>
    lower_colnames() |>
    check_data_colnames_format() |>
    drop_ungraded_assignments()
```


### process_id()
This function drops any students with missing student IDs and merges any replicated students based on the following criteria. If the assignment cell is a datetime, it removes NAs and takes the last datetime. If the assignment cell is numeric, it takes the max. If the assignment cell is NA, leave as NA. If there are no issues on a student level, there is no change. The processed data is returned with no missing student IDs nor any duplicated students.

```{r}
gs_demo |>
    lower_colnames() |>
    check_data_colnames_format() |>
    drop_ungraded_assignments() |>
    process_id()
```

### process_assignments()
This function removes any white spaces and special characters from column names. This cleans up column names for future processing.

```{r}
gs_demo |>
    lower_colnames() |>
    check_data_colnames_format() |>
    drop_ungraded_assignments() |>
    process_id() |>
    process_assignments()
```

### pivot_gs()
This function applies the pivot-longer function to allow for unit of observation be a student + individual assignment.

```{r}
pivot_df <- gs_demo |>
    lower_colnames() |>
    check_data_colnames_format() |>
    drop_ungraded_assignments() |>
    process_id() |>
    process_assignments() |>
    pivot_gs()

pivot_df
```

### Load in policy file
The policy file is broken down into three separate parts: coursewide information, categories and cutoffs. Coursewide information includes the course name and a course description; this is purely for the user. Each category is a subset of the overall grade and includes information about how the scores of the assignments within the category are aggregated: this information includes lateness penalties, how the assignments are weighted within the category and how categories are weighted in the overall grade. Finally, the cutoffs describe the lower cutoff for each letter grade. For example, if the cutoff for a "A" is 90, a student earns an "A" if their overall grade is at least 90%. Below is the demo policy file found within the package.

```{r}
policy_demo
```

### Creating a Policy File
Any empty policy file can be created with the `create_empty_policy_file()` function, which takes a single numeric input to specify how many categories this policy file has. The function defaults to just one category. This returns a list with the correct policy-file formatting and default values for all inputs.

```{r}
create_empty_policy_file(num_cat = 2)
```


### check_names()
This function validates that the policy file has the right format in terms of names and nesting. If there is incorrect formatting, it returns an error with information about what formatting is missing. If the policy file is correctly formatted, it returns the policy file as is in order to make these functions pipeable.

```{r}
policy_demo|>
    check_names()
```

### check_assignment_names()
This function checks that the assignments within the policy file can be found within the Gradescope data. If there is an assignment in the policy file that does not occur in the Gradescope data, an error is returned, including which assignments have no student data. If there is no error, the same policy file is return to keep these functions pipeable. This part of the process should be done after validating the Gradescope data and converting it into its pivotted format with `pivot_gs()` pipline as explained and demonstrated above. In this example, `pivot_df` is the pivotted result of `gs_demo` going thorugh this pipeline.

```{r}
policy_demo |>
    check_names()|>
    check_assignment_names(pivot_df = pivot_df)
```

### create_assigns_table()
This function creates an assignment table where each row is an assignment with its relevant category information. This is an intermediary table that makes it easier to combine the information from the policy file with the pivoted data from the Gradescope data. 

```{r}
policy_demo|>
    check_names()|>
    check_assignment_names(pivot_df = pivot_df) |>
    create_assigns_table()
```

### data_merge_assigns()
This function combines the grading criteria from the policy file with the student-assignment data from the Gradescope data, which is now in its pivotted form. At this point, the resulting dataframe's unit of observation is a student's individual assignment. Each row includes the student's scores and lateness information as well as information about the assignment's grading criteria based on its respective category. The purpose of combining these two original inputs -- the Gradescope data and the policy file -- is to allow all following grading computations to utilize only one merged file.

```{r}
policy_demo|>
    check_names()|>
    check_assignment_names(pivot_df = pivot_df) |>
    create_assigns_table() |>
    data_merge_assigns(pivot_df = pivot_df)
```

### Grading
TBD