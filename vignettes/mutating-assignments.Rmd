---
title: "Mutating Assignments for Each Sub-Category"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Nested Grouped Operations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  warning = FALSE
)
```

Here's an approach of mutating a new assignment for each sub-category and category as well as the overall course grade. In this case, we'll assume that each assignment consists of three columns: its raw-score, its percentage, and its maximum points. For example, an assignment called `lab1` will have those three columns with the corresponding names: `lab1`, `lab1_score` and `lab1_max_pts`.

Here's an example of gs_wide:

```{r}
library(tidyverse)

gs_data <- tibble(
  sid = c(007),
  ps_1_written = c(8),
  ps_1_written_score = c(.8),
  ps_1_written_max_pts = c(10),
  ps_1_code = c(4),
  ps_1_code_score = c(.8),
  ps_1_code_max_pts = c(5),
  ps_2_written = c(9),
  ps_2_written_score = c(.9),
  ps_2_written_max_pts = c(10),
  ps_2_code = c(5),
  ps_2_code_score = c(1),
  ps_2_code_max_pts = c(5),
  final_exam = c(95),
  final_exam_score = c(.95),
  final_exam_max_pts = c(100)
)
```

I'm assuming that there are five methods of aggregation: weight by points, weight equally (or weight by percent), weight by weights (explicitly giving weights), min and max. I've not written functions for the latter two, and keep in mind that the code I have written is crude and nowhere near efficient.

YOU CAN SKIP TO THE EXAMPLE OF THESE FUNCTIONS RUN TOGETHER AT THE BOTTOM!

Here's the function for weighting by points:

```{r}
by_points <- function(gs_data, aggregate_assign, sub_assigns,...){
  total_raw <- gs_data |>   #sum up all earned points
    rowwise() |>
    summarize(raw = sum(c_across(sub_assigns))) %>%
    pull()
  
  max_cols <- paste0(sub_assigns, "_max_pts")
  
  total_max <- gs_data |>   #sum up all max points
    rowwise() |>
    summarize(raw = sum(c_across(max_cols))) %>%
    pull()
  
  gs_data <- gs_data |>
    mutate(raw = total_raw, #raw pts for whole category
           score = total_raw/total_max, #computed percentage for whole category
           max = total_max) #total max points for whole category
  l <- length(colnames(gs_data))
  #below is naming columns by my convention of `lab1`, `lab1_score` and `lab1_max_pts`
  colnames(gs_data)[(l-2):l] <- paste0(aggregate_assign, c("", "_score", "_max_pts"))
  
  return (gs_data)
}
```

Here's the function for weighting by percent:

```{r}
by_percent <- function(gs_data, aggregate_assign, sub_assigns){
  percent_cols <- paste0(sub_assigns, "_score")
  
  total_percent <- gs_data |> #get total score for category
    rowwise() |>
    summarize(raw = mean(c_across(percent_cols))) %>%
    pull()
  
  max_cols <- paste0(sub_assigns, "_max_pts")
  
  total_max <- gs_data |> #get total max_pts for category
    rowwise() |>
    summarize(raw = sum(c_across(max_cols))) %>%
    pull()
  
  gs_data <- gs_data |>
    mutate(raw = total_percent*total_max, #computed raw_pts for category
           score = total_percent, #score for category
           max = total_max) #total max_pts for category
  l <- length(colnames(gs_data))
    #below is naming columns by my convention of `lab1`, `lab1_score` and `lab1_max_pts`
  colnames(gs_data)[(l-2):l] <- paste0(aggregate_assign, c("", "_score", "_max_pts"))
  
  return (gs_data)
}
```

Here's the function for weighting by explicit weights: (note this is VERY similar to by_percent, the only difference is the furst `summarize()`)

```{r}
by_weight <- function(gs_data, aggregate_assign, sub_assigns, weights) {
  percent_cols <- paste0(sub_assigns, "_score")
  
  total_percent <- gs_data |> #get total score for category
    rowwise() |>
    summarize(raw = sum(c_across(percent_cols)*weights)) %>% #uses weights
    pull()
  
  max_cols <- paste0(sub_assigns, "_max_pts")
  
  total_max <- gs_data |> #get total max_pts for category
    rowwise() |>
    summarize(raw = sum(c_across(max_cols))) %>%
    pull()
  
  gs_data <- gs_data |>
    mutate(raw = total_percent*total_max, #computed raw_pts for category
           score = total_percent, #score for category
           max = total_max) #total max_pts for category
  
  l <- length(colnames(gs_data))
  #below is naming columns by my convention of `lab1`, `lab1_score` and `lab1_max_pts`
  colnames(gs_data)[(l-2):l] <- paste0(aggregate_assign, c("", "_score", "_max_pts"))
  
  return (gs_data)
  
}
```


Here is the function that literally does nothing.
```{r}
none <- function(data){
    return (data)
}
```


## SKIP TO HERE FOR EXAMPLE

Here's an example of how these functions would be run sequentially: (I'm assuming this order will be determined by `map_depth()` and these functions will be called depending on the policy file)

```{r}
grades <- gs_data |>
  by_percent(aggregate_assign = "ps_1", sub_assigns = c("ps_1_written", "ps_1_code") ) |>
  by_percent(aggregate_assign = "ps_2", sub_assigns = c("ps_2_written", "ps_2_code") ) |>
  by_percent(aggregate_assign = "problem_sets", sub_assigns = c("ps_1", "ps_2")) |>
  by_percent(aggregate_assign = "exam", sub_assigns = c("final_exam")) |>
  by_weight(aggregate_assign = "course_grade", sub_assigns = c("problem_sets", "exam"), weights = c(0.6, 0.4))

```

I've pivoted so it prints better for the vignette:
```{r}
print.data.frame(pivot_longer(grades, cols = colnames(grades)))
```


```{r}
formatted_policy <- list(
  name = list("course_grade", "problem_sets","exam", "ps1", "ps2", 
              "ps_1_written", "ps_1_code", "ps_2_written","ps_2_code", "final_exam"),
  aggregation = list("by_weight", "by_percent", "by_percent", "by_points", "by_points", "none", "none", 
                     "none", "none", "none"),
  assignments = list(c("problem_sets", "exam"),c("ps1", "ps2"), c("final_exam"), 
                     c("ps_1_written", "ps_1_code"), 
                     c("ps_2_written","ps_2_code"), NA, NA, NA, NA, NA),
  nested_level = list(0, 1, 1, 2, 2, 3,3,3,3, 3)
)

# hypothetically, lets use pmap nested inside an modify
pmap_function <- function(aggregate_assign, aggregation,sub_assigns, ...){
    if (aggregation ==  "by_points"){
       return ( by_points(gs_data = gs_data, aggregate_assign = aggregate_assign, 
                          sub_assigns = sub_assigns) )
    } else if (aggregation == "by_percent"){
        return ( by_percent(gs_data = gs_data, aggregate_assign = aggregate_assign, 
                            sub_assigns = sub_assigns) )
    } else if (aggregation == "by_weight"){
        return ( by_weight(gs_data = gs_data, aggregate_assign = aggregate_assign, 
                           sub_assigns = sub_assigns) )
    }
    
    #default == none
    return (none())
}
```
##TESTING with `pmap`
```{r}
gs_data |>
    pmap_function(aggregate_assign = "ps1", 
                              sub_assigns = c("ps_1_written", "ps_1_code"), 
                              aggregation = "by_points")
aggregate_assign <- list("ps1", "ps2")
sub_assigns <- list(c("ps_1_written", "ps_1_code"), c("ps_2_written", "ps_2_code"))
aggregation <- list("by_points", "by_points")
baby_policy <- list(aggregate_assign, aggregation, sub_assigns)

grading_with_just_pmap <- pmap(baby_policy, pmap_function)

grading_with_just_pmap

```

```{r}
#hypothetically, this setup???

# pmap_with_modify <- function(gs_data, aggregate_assign, aggregation,sub_assigns, ...){
#     if (aggregation ==  "by_points"){
#        return ( by_points(gs_data = gs_data, aggregate_assign = aggregate_assign, 
#                           sub_assigns = sub_assigns) )
#     } else if (aggregation == "by_percent"){
#         return ( by_percent(gs_data = gs_data, aggregate_assign = aggregate_assign, 
#                             sub_assigns = sub_assigns) )
#     } else if (aggregation == "by_weight"){
#         return ( by_weight(gs_data = gs_data, aggregate_assign = aggregate_assign, 
#                            sub_assigns = sub_assigns) )
#     }
#     
#     #default == none
#     return (none())
# }
# 
# 
# modify2(gs_data,list(aggregate_assign, aggregation, sub_assigns), pmap(list(~.x, unlist(~.y)), pmap_function))
```



